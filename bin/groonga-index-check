#!/usr/bin/env ruby
# coding: utf-8
# -*- ruby -*-
#
# Copyright (C) 2015-2016  Kouhei Sutou <kou@clear-code.com>
# Copyright (C) 2017 Kentaro Hayashi <hayashi@clear-code.com>
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

require "optparse"
require "json"

require "groonga/client"

module Groonga
  class Client
    class IndexCheckCommand
      def initialize
        @protocol = :http
        @host     = "localhost"
        @port     = 10041
        @check_missing_source = false
        @check_index_integrity = false
        @target = false
      end

      def run(argv)
        command_file_paths = parse_command_line(argv)

        @client = Client.new(:protocol => @protocol,
                             :host     => @host,
                             :port     => @port,
                             :read_timeout => @read_timeout,
                             :backend  => :synchronous)
        options = {
          :check_missing_source => @check_missing_source,
          :check_index_integrity => @check_index_integrity,
          :target => @target
        }
        checker = Checker.new(@client, options)
        checker.check
        true
      end

      private
      def parse_command_line(argv)
        parser = OptionParser.new
        parser.version = VERSION
        #parser.banner += " GROONGA_COMMAND_FILE1 GROONGA_COMMAND_FILE2 ..."

        parser.separator("")

        parser.separator("Mode:")

        parser.on("--check-missing-source",
                  "Check whether there is an index column which lacks index source.",
                  "(false)") do
          @check_missing_source = true
        end

        parser.on("--check-index-integrity",
                  "Check whether there is an index column which lacks index source.",
                  "(false)") do
          @check_index_integrity = true
        end

        parser.on("--target=TABLE_OR_INDEX",
                  "Check which table or index should be checked.",
                  "(all indexes)") do |table_or_index|
          @target = table_or_index.split(",")
        end

        parser.separator("Connection:")

        parser.on("--host=HOST",
                  "Groonga server to be connected.",
                  "(#{@host})") do |host|
          @host = host
        end

        parser.on("--port=PORT", Integer,
                  "Port number of Groonga server to be connected.",
                  "(auto)") do |port|
          @port = port
        end

        parser.parse(argv)
      end

      class Checker
        def initialize(client, options)
          @client = client
          @options = options
        end

        def support_schema_command?
          response = @client.status
          if response.success?
            return Gem::Version.new('5.0.9') < Gem::Version.new(response.body["version"])
          else
            puts response.error_message
          end
          false
        end

        def check
          @support_schema = support_schema_command?
          if @options[:check_missing_source]
            check_missing_source
          end
          if @options[:check_index_integrity]
            check_index_integrity
          end
        end

        def check_target_table?(table_name)
          unless @options[:target]
            return true
          end
          if @options[:target].kind_of?(Array)
            @options[:target].each do |name|
              table_part = name.split(".").first
              return true if table_name == table_part
            end
          end
          false
        end

        def check_target_column?(column)
          unless @options[:target]
            return column["type"] == "index"
          else
            unless column["type"] == "index"
              return false
            end
          end
          if @options[:target].kind_of?(Array)
            @options[:target].each do |name|
              table_part = name.split(".").first
              return true if name == "#{column['domain']}.#{column['name']}" or
                name == column["domain"]
            end
          end
          false
        end

        def check_missing_source
          missing_indexes = []
          @client.table_list.each do |table|
            unless check_target_table?(table["name"])
              next
            end
            @client.column_list(:table => table["name"]).each do |column|
              unless check_target_column?(column)
                next
              end
              if column["type"] == "index" and column["source"].empty?
                missing_indexes << "#{column['domain']}.#{column['name']}"
              end
            end
          end
          missing_indexes.each do |column|
            puts "index column:<#{column}> is missing source."
          end
        end

        def list_tokens(table_name)
          keys = []
          response = @client.select(:table => table_name,
                                    :limit => -1,   
                                    :output_columns => :_key)
          if response.success?
            keys = response.records.collect do |record|
              record["_key"]
            end
          else
            puts response.error_message
          end
          keys
        end
                                       
        def verify_tokens(table_name, old_column, new_column, tokens)
          broken_index_tokens = []
          tokens.each do |token|
            query = Groonga::Client::ScriptSyntax.format_string(token)
            response1 = @client.select(:table => table_name,
                                       :match_columns => old_column,
                                       :query => query,
                                       :output_columns => :_id,
                                       :limit => -1,
                                       :sort_keys => :_id)
            response2 = @client.select(:table => table_name,
                                       :match_columns => new_column,
                                       :query => query,
                                       :output_columns => :_id,
                                       :limit => -1,
                                       :sort_keys => :_id)
            response1_ids = response1.records.collect do |value|
              value["_id"]
            end
            response2_ids = response2.records.collect do |value|
              value["_id"]
            end
            if response1_ids != response2_ids
              broken_index_tokens << token
            end
          end
          broken_index_tokens                                                
        end
                              
        def check_index_integrity
          p @options
          table_names = @client.table_list.collect do |table|
            if check_target_table?(table["name"])
              table["name"]
            end
          end.compact
          target_columns = []
          table_names.each do |table_name|
            target_columns = @client.column_list(:table => table_name).collect do |column|
              if check_target_column?(column)
                p column
                column
              end
            end.compact
          end
          p target_columns
          target_columns.each do |column|
            table_name = column["domain"]
            column_name = column["name"]
            suffix = Time.now.strftime("%Y%m%d%H%M%S_%N")
            new_column_name = "#{column_name}_#{suffix}"
            type, source = column["source"].first.split(".")
            flags = column["flags"].sub(/\|PERSISTENT/,'')
            response = @client.column_create(:table => table_name,
                                             :name => new_column_name,
                                             :flags => flags,
                                             :type => type,
                                             :source => source)
            unless response.success?
              puts response.error_message
              next
            end
            
            tokens = list_tokens(table_name)
            puts "check #{tokens.count} tokens against <#{table_name}.#{column_name}>."
            broken_index_tokens = verify_tokens(table_name, column_name,
                                                new_column_name, tokens)
            @client.column_remove(:table => table_name,
                                  :name => new_column_name)
            unless response.success?
              puts response.error_message
              next
            end
            if broken_index_tokens.empty?
              puts "#{table_name}.#{column_name} is valid."
            else
              puts "#{table_name}.#{column_name} is broken."
            end
          end
        end
      end
    end
  end
end

require "groonga/client/cli"

index_checker = Groonga::Client::IndexCheckCommand.new
exit(index_checker.run(ARGV))
